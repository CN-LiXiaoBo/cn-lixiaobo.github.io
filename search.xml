<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何定位慢查询SQL以及优化</title>
      <link href="/2022/10/03/%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2SQL%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/2022/10/03/%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2SQL%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="慢查询日志记录慢SQL"><a href="#慢查询日志记录慢SQL" class="headerlink" title="慢查询日志记录慢SQL"></a>慢查询日志记录慢SQL</h2><p>定位慢SQL可以通过慢查询日志来查看慢SQL，默认的情况下，MySQL数据库不开启慢查询日志(slow query log)，需要手动把它打开<br>SET GLOBAL slow_query_log = ‘ON’;<br><img src="https://img-blog.csdnimg.cn/ca5a435941b34b31ac9d3667f4b1796f.png" alt="在这里插入图片描述"></p><p><strong>查看下慢查询日志配置</strong><br>SHOW VARIABLES LIKE ‘slow_query_log%’</p><p>slow_query_log：表示慢查询开启的状态<br>slow_query_log_file：表示慢查询日志存放的位置</p><p><strong>查看超过多少时间，才记录到慢查询日志</strong><br>SHOW VARIABLES LIKE ‘long_query_time’</p><p>注意： 这样配置是临时的如果需要永久修改需要去配置文件(/etc/my.cnf)</p><h2 id="explain查看分析SQL执行计划"><a href="#explain查看分析SQL执行计划" class="headerlink" title="explain查看分析SQL执行计划"></a>explain查看分析SQL执行计划</h2><p>通过慢查询日志定位出查询效率较低的SQL，可以使用explain查看SQL的执行计划<br><img src="https://img-blog.csdnimg.cn/363d74d85a864fafb0c7dc973c65b02f.png" alt="在这里插入图片描述"></p><p><strong>id</strong></p><blockquote><p><strong>1. id 值相同时，被视为一组从上向下执行。</strong><br><strong>2. 如果是子查询，id 值会递增，id 值越高，优先级越高</strong><br><strong>3. id为NULL最后执行</strong></p></blockquote><p><strong>select_type</strong></p><blockquote><p><strong>1. simple: 简单的select, 查询中不包含子查询或者 union。例如: select name from student where id= 100<br>2. primary: 子查询中最外层查询, 查询中若包含任何复杂的子部分, 最外层的select被标记为primary<br>3. derived：在 from 的列表中包含的子查询被标记成 derived（派生表）。例如: explain select id from (select id,name from student) student1 where name= ‘name100’<br>4. subquery：在 select 或 where 列表中包含了子查询，则子查询被标记成 subquery。例如: explain select id from student where score = (select score from student where<br>name=’name100’);<br>5. union: union中的第二个或后面的select语句. 例如: EXPLAIN select id from student where id&lt;12691055 UNION all select id from student where id&lt;12691060;</strong></p></blockquote><p><strong>table</strong></p><blockquote><p><strong>显示这一步所访问数据库中表名称. 有时候不是真实的表名, 可能是简称</strong></p></blockquote><p><strong>partitions</strong></p><blockquote><p><strong>该字段看table所在的分区, 值为NULL表示表未被分区</strong></p></blockquote><p><strong>possible_keys</strong></p><blockquote><p><strong>可能会使用到的索引(ps.其实不太重要)</strong></p></blockquote><p><strong>重点关注的字段</strong><br><strong>type</strong></p><blockquote><p><strong>表示连接类型，查看索引执行情况的一个重要指标 以下性能从好到坏依次：system &gt; const &gt; eq_ref &gt; ref &gt;<br>ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt;<br>index &gt; ALL<br>system：这种类型要求数据库表中只有一条数据，是const类型的一个特例，一般情况下是不会出现的<br>const：通过一次索引就能找到数据，一般用于主键或唯一索引作为条件，这类扫描效率极高，速度非常快<br>eq_ref：常用于主键或唯一索引扫描，一般指使用主键的关联查询 ref : 常用于非主键和唯一索引扫描<br>ref_or_null：这种连接类型类似于ref，区别在于MySQL会额外搜索包含NULL值的行<br>index_merge：使用了索引合并优化方法，查询使用了两个以上的索引<br>unique_subquery：类似于eq_ref，条件用了in子查询<br>index_subquery：区别于unique_subquery，用于非唯一索引，可以返回重复值<br>range：常用于范围查询，比如：between … and 或 In 等操作 index：全索引扫描 ALL：全表扫描</strong></p></blockquote><p><strong>key</strong></p><blockquote><p><strong>实际使用到的索引</strong></p></blockquote><p><strong>key_len</strong></p><blockquote><p><strong>实际使用到的索引的长度</strong></p></blockquote><p><strong>rows</strong></p><blockquote><p><strong>该列表示MySQL估算找到我们所需的记录，需要读取的行数</strong></p></blockquote><p><strong>filtered</strong></p><blockquote><p><strong>该列是一个百分比，是满足条件的记录数量与我们查询了多少记录数量的比值</strong></p></blockquote><p><strong>extra</strong></p><blockquote><p><strong>该字段包含有关MySQL如何解析查询的其他信息，它一般会出现这几个值：<br>● Usingfilesort：表示按文件排序，一般是在指定的排序和索引排序不一致的情况才会出现，一般见于order by语句<br>● Using index：表示是否用了覆盖索引<br>● Using temporary: 表示是否使用了临时表,性能特别差，需要重点优化，一般多见于groupby语句，或者union语句<br>● Using where : 表示使用了where条件过滤<br>● Using index condition：MySQL5.6之后新增的索引下推，在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据</strong></p></blockquote><h2 id="profile分析执行耗时"><a href="#profile分析执行耗时" class="headerlink" title="profile分析执行耗时"></a>profile分析执行耗时</h2><blockquote><p><strong>explain只是看到SQL预估的执行计划，如果要了解SQL真正的执行线程状态及消耗的时间，需要使用profiling，开启profiling参数后，后续执行的SQL语句都会记录其资源开销，包括IO，上下文切换，CPU，内存等等，可以根据这些开销进一步分析当前慢SQL的瓶颈再进一步进行优化</strong></p></blockquote><p><img src="https://img-blog.csdnimg.cn/c556a8c892074bc08daf7cac58ba8d5f.png" alt="在这里插入图片描述"></p><h2 id="Optimizer-Trace分析详情"><a href="#Optimizer-Trace分析详情" class="headerlink" title="Optimizer Trace分析详情"></a>Optimizer Trace分析详情</h2><blockquote><p><strong>profile只能查看到SQL的执行耗时，但无法看到SQL真正执行的过程信息，不知道MySQL优化器是如何选择执行计划，这时候，可以使用Optimizer<br>Trace，它可以跟踪执行语句的解析优化执行的全过程</strong></p></blockquote><p><img src="https://img-blog.csdnimg.cn/f1315716958849f9a15717c99201a7f0.png" alt="在这里插入图片描述"></p><p>三个阶段分为对应：准备阶段、分析阶段、执行阶段</p><h1 id="确定问题采用响应措施"><a href="#确定问题采用响应措施" class="headerlink" title="确定问题采用响应措施"></a>确定问题采用响应措施</h1><p>● 多数慢SQL都跟索引有关，比如不加索引，索引不生效、不合理等，这时候，可以优化索引<br>● 还可以优化SQL语句，比如一些in元素过多问题(分批)，深分页问题(基于上一次数据过滤等)，进行时间分段查询<br>● SQL没办法很好优化，可以改用ES的方式，或者数仓<br>● 如果单表数据量过大导致慢查询，可以考虑分库分表<br>● 如果数据库在刷脏页导致慢查询，考虑是否可以优化一些参数<br>● 如果存量数据量太大，考虑是否可以让部分数据归档</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL优化 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引的学习与理解</title>
      <link href="/2022/10/02/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
      <url>/2022/10/02/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么使用索引"><a href="#为什么使用索引" class="headerlink" title="为什么使用索引"></a>为什么使用索引</h2><p>索引是存储引擎用于快速找到数据记录的一种数据结构。MySQL在进行数据查找时，首先查看查询条件是否命中某条索引，符合则<strong>通过索引查找</strong>相关数据，如果不符合则<strong>全表扫描</strong>，建索引目的就是为了<strong>减少磁盘I/O次数</strong>，加快查询效率。</p><h2 id="索引及其优缺点"><a href="#索引及其优缺点" class="headerlink" title="索引及其优缺点"></a>索引及其优缺点</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><blockquote><p><strong>索引本质</strong>：索引是数据结构。这些数据结构以某种方式指向数据，这样可以在这些数据结构的基础上实现高效查找算法。<br><strong>索引是在存储引擎实现的</strong>，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有类型的索引。同时存储引擎可以定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote><p>1、提高数据检索的效率，降低数据库的I/O成本<br>2、通过创建唯一索引，可以保证数据库表中每一行数据的唯一性<br>3、可以加速表和表之间的连接。对于有依赖关系的子表和父表联合查询时，可以提高查询速度<br>4、在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低CPU的消耗</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>1、创建索引和维护索引要耗费时间<br>2、索引需要占磁盘空间，存储在磁盘上<br>3、虽然索引大大提高了查询 速度，同时也会降低更新表的速度</p></blockquote><h2 id="InnoDB中的索引"><a href="#InnoDB中的索引" class="headerlink" title="InnoDB中的索引"></a>InnoDB中的索引</h2><h3 id="常见索引概念"><a href="#常见索引概念" class="headerlink" title="常见索引概念"></a>常见索引概念</h3><blockquote><p><strong>聚簇索引</strong> 并不是一种单独的索引类型，而是一种数据存储方式（所有的用户记录都存储在了叶子节点）。<br><strong>特点</strong><br>1、使用主键值的大小进行记录和页的排序<br>页内的记录是按照主键大小顺序排成一个单向链表<br>各个存放用户记录的页排序成一个双向链表<br>存放目录项的页也排成一个双向链表<br>2、B+树的叶子节点存储的是完整的用户记录<br><strong>优点</strong><br>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引获取数据比非聚簇索引更快<br>聚簇索引对于主键的排序查找和范围查找更快<br>因为聚簇索引排列顺序，查询显示一定范围数据时不用从多个数据块中提取数据，节省了大量I/O操作<br><strong>缺点</strong><br>插入速度严重依赖插入顺序，按照主键的顺序插入是最快的方式，否则会出现页分裂，严重影响性能<br>更新主键的代价很高，因为将会导致被更新的行移动<br>二级索引需要两次索引查找</p></blockquote><blockquote><p><strong>非聚簇索引</strong>与聚簇索引的区别就是叶子节点放的是主键</p></blockquote><h2 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h2><blockquote><p><strong>空间上的代价</strong><br>每建立一颗B+树，每一颗B+树的每一个节点都是一个数据页，一个页默认占用16kb的存储空间，一颗很大的B+树由许多数据页组成<br><strong>时间上的代价</strong><br>每次对表中数据进行<strong>增删改</strong>操作时，都需要去修改各个B+树索引</p></blockquote><h2 id="索引的声明与使用"><a href="#索引的声明与使用" class="headerlink" title="索引的声明与使用"></a>索引的声明与使用</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><blockquote><p>从<strong>功能逻辑</strong>分为普通索引、唯一索引、主键索引、全文索引<br>从<strong>物理实现</strong>方式分聚簇索引和非聚簇索引<br>从<strong>作用字段个数</strong>分单列索引和联合索引</p></blockquote><blockquote><p><strong>普通索引</strong><br>在创建索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在任何数据类型</p></blockquote><blockquote><p><strong>唯一索引</strong><br>使用UNIQUE参数可以设置唯一性索引，在创建唯一性索引时限制该索引的值必须是唯一的，但允许有空值。一张数据表里可以有多个唯一索引</p></blockquote><blockquote><p><strong>主键索引</strong><br>主键索引就是一种特殊的唯一性索引，不能为空且最多只有一个主键索引</p></blockquote><blockquote><p><strong>单列索引</strong><br>在单个字段创建索引</p></blockquote><blockquote><p><strong>多列索引</strong><br>多个字段组合上创建一个索引，使用组合索引时需要遵循<strong>最左前缀集合</strong></p></blockquote><blockquote><p><strong>全文索引</strong><br>利用分词技术等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法智能的筛选出我们想要的搜索结果。全文索引适合大型数据集，对于小的数据集，用处不大。<br>使用参数FULLTEXT设置全文索引</p></blockquote><h3 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h3><blockquote><p>查看索引<br>show create table 表名；<br>show index from 表名；</p></blockquote><blockquote><p>在<strong>创建表的定义语句</strong>中指定索引列，使用<strong>alter table</strong>语句或者<strong>create index</strong></p></blockquote><blockquote><p><strong>创建表时</strong><br><strong>隐式创建索引</strong><br>添加约束的时候自动创建<br><strong>显示创建索引</strong><br>create table table_name(<br>name varchar(30),<br>[unique | fulltext | spatial] [index | key] (col_name [length]) [asc | desc])<br><strong>alter table</strong><br>alter table 表名 add index 索引名(字段名)<br><strong>create index</strong><br>create index 索引名 on 表名(字段名)</p></blockquote><h3 id="索引的删除"><a href="#索引的删除" class="headerlink" title="索引的删除"></a>索引的删除</h3><blockquote><p>alter table .. drop index …<br>drop index … on table_name</p></blockquote><h2 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h2><blockquote><p>1.针对数据量较大,且查询比较频繁的表建立索引<br>2.针对于常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引<br>3.尽量选择区分度高的列作为索引,尽量建立唯一索引,区分度越高,使用索引的效率越高<br>4.如果是字符串类型的字段,字段的长度较长,可以针对字段的特点建立前缀索引<br>5.尽量使用联合索引,减少单列索引,查询时,联合索引很多时候可以覆盖索引,节省存储空间,避免回表,提高查询效率<br>6.要控制索引的数量,索引并不是多多益善,索引越多,维护索引结构的代价也就越大,会影响增删改的效率<br>7.如果索引列不能存储NULL值,请在创建表时使用NOT NULL约束它.当优化器知道每列是否包含NULL值时,它可以更好的确定那个索引最有效的用于查询</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 面试 </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
